<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¡”é˜²éŠæˆ²V1.1</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            background-color: #1e1e1e; /* æ·±è‰²èƒŒæ™¯ */
            color: #e0e0e0;
            margin: 0;
            padding: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }

        /* éŠæˆ²å®¹å™¨ */
        #game-container {
            max-width: 800px;
            width: 100%;
            margin: 0 auto; /* æ°´å¹³ç½®ä¸­ */
            background-color: #2d2d2d;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative; /* ç”¨æ–¼å®šä½ç ”ç©¶é¢æ¿ */
        }

        /* æ¨™é¡Œåˆ— */
        .game-header {
            background-color: #252525;
            padding: 12px 20px;
            font-size: 1.25rem;
            font-weight: bold;
            color: #fff;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .version-badge {
            background-color: #4CAF50;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        /* ä¿æŒç•«å¸ƒé•·å¯¬æ¯”çš„åŒ…è£¹å™¨ (800x480 = 10:6 = 100:60) */
        .canvas-wrapper {
            position: relative;
            width: 100%;
            padding-top: 60%; /* 60% = 480 / 800 * 100% */
            background-color: #000;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #5a8c49; /* è‰åœ°é¡è‰² */
            border-bottom: 2px solid #444;
        }

        /* UI é¢æ¿ */
        #ui-panel {
            padding: 16px;
            background-color: #3a3a3a;
            border-top: 2px solid #444;
        }

        #stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 16px;
            font-size: 1.1rem;
            font-weight: 600;
        }

        #stats span {
            padding: 8px 12px;
            background-color: #4a4a4a;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3) inset;
            min-width: 80px;
            text-align: center;
        }

        #controls {
            display: flex;
            flex-wrap: wrap; /* å…è¨±æŒ‰éˆ•æ›è¡Œ */
            gap: 12px;
            justify-content: center;
        }

        button {
            font-family: inherit;
            font-size: 1rem;
            font-weight: 600;
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background-color: #5c5c5c;
            color: #ffffff;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            flex-grow: 1; /* æŒ‰éˆ•è‡ªå‹•å¡«æ»¿ç©ºé–“ */
            min-width: 120px; /* æœ€å°å¯¬åº¦ */
            position: relative; /* ç”¨æ–¼å®šä½åƒ¹æ ¼æ¨™ç±¤ */
            overflow: hidden; /* ç¢ºä¿é€²åº¦æ¢ä¸æº¢å‡º */
        }

        button.start-wave {
            background-color: #4CAF50; /* ç¶ è‰² */
        }
        
        button.tower-buy {
            background-color: #008CBA; /* è—è‰² */
            z-index: 1;
        }
        
        button.tower-buy.selected,
        button.tower-buy:hover:not(:disabled):not(.locked):not(.unlocking) {
            background-color: #00aeff;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        /* é–å®šç‹€æ…‹çš„æŒ‰éˆ• */
        button.tower-buy.locked {
            background-color: #444;
            border: 2px dashed #666;
            color: #aaa;
        }
        button.tower-buy.locked:hover:not(.expensive) {
            background-color: #555;
            color: #fff;
            border-color: #ffd700; /* é‡‘è‰²é‚Šæ¡†æç¤ºè§£é– */
        }

        /* è§£é–ä¸­ç‹€æ…‹ */
        button.tower-buy.unlocking,
        button.research-btn.unlocking {
            background-color: #555;
            border: 2px solid #ffd700;
            color: #fff;
            cursor: wait;
        }
        
        /* é€²åº¦æ¢èƒŒæ™¯ */
        .progress-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background-color: rgba(255, 215, 0, 0.3); /* é‡‘è‰²åŠé€æ˜ */
            z-index: -1;
            transition: width 0.1s linear;
        }

        /* è‡ªå‹•å»ºé€ æŒ‰éˆ•æ¨£å¼ */
        #autoBuildBtn {
            background-color: #9c27b0; /* ç´«è‰² */
            border: 2px solid transparent;
        }
        #autoBuildBtn.active {
            background-color: #7b1fa2;
            border-color: #e1bee7;
            box-shadow: 0 0 10px #9c27b0;
        }

        /* ç ”ç©¶å®¤æŒ‰éˆ• */
        #researchToggleBtn {
            background-color: #FF9800; /* æ©˜è‰² */
        }
        #researchToggleBtn:hover {
            background-color: #F57C00;
        }

        button:disabled {
            background-color: #757575;
            color: #b0b0b0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        /* é‡‘éŒ¢ä¸è¶³æ™‚çš„æ¨£å¼ (ä¸ç¦ç”¨ï¼Œä½†è®Šç´…) */
        button.expensive {
            opacity: 0.7;
            color: #ff8888;
        }

        /* éŠæˆ²çµæŸ/ç²å‹å½ˆçª— */
        #popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 40px;
            border-radius: 16px;
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            display: none; /* é è¨­éš±è— */
            z-index: 100;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
        }

        /* æµ®å‹•è¨Šæ¯æ¨£å¼ */
        #message {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 50, 50, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 50px;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 101;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        /* æˆåŠŸè¨Šæ¯æ¨£å¼ */
        #message.success {
            background-color: rgba(50, 200, 50, 0.9);
        }

        /* ç ”ç©¶é¢æ¿ */
        #researchPanel {
            position: absolute;
            bottom: 80px; /* åœ¨æ§åˆ¶åˆ—ä¸Šæ–¹ */
            right: 20px;
            width: 300px;
            background-color: rgba(40, 40, 40, 0.95);
            border: 1px solid #666;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 102;
            display: none; /* é è¨­éš±è— */
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .research-header {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #555;
            padding-bottom: 8px;
        }

        .research-item {
            margin-bottom: 16px;
            background-color: #333;
            padding: 10px;
            border-radius: 8px;
        }

        .research-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.95rem;
        }

        .research-desc {
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 8px;
        }

        .research-btn {
            width: 100%;
            padding: 8px;
            font-size: 0.9rem;
            background-color: #00897B; /* è—ç¶ è‰² */
            position: relative;
            overflow: hidden;
        }
        .research-btn:hover:not(:disabled):not(.unlocking) {
            background-color: #00796B;
        }
        .research-btn.maxed {
            background-color: #555;
            color: #888;
            border: 1px solid #666;
        }

    </style>
</head>
<body>

    <div id="game-container">
        <!-- æ–°å¢æ¨™é¡Œåˆ— -->
        <div class="game-header">
            å¡”é˜²éŠæˆ² <span class="version-badge">V1.1</span>
        </div>

        <!-- ç•«å¸ƒåŒ…è£¹å™¨ -->
        <div class="canvas-wrapper">
            <canvas id="gameCanvas" width="800" height="480"></canvas>
            <!-- è¨Šæ¯æç¤º -->
            <div id="message"></div>
            <!-- éŠæˆ²çµæŸå½ˆçª— -->
            <div id="popup"></div>
            
            <!-- ç ”ç©¶é¢æ¿ (ç§»åˆ° canvas-wrapper å…§æ–¹ä¾¿å®šä½æˆ–ç”¨ absolute) -->
            <div id="researchPanel">
                <div class="research-header">
                    <span>ğŸ”¬ ç§‘æŠ€ç ”ç©¶å®¤</span>
                    <span style="cursor:pointer; font-size:1.5rem;" id="closeResearch">Ã—</span>
                </div>
                
                <!-- ç ”ç©¶é …ç›® 1: ç ”ç™¼åŠ é€Ÿ -->
                <div class="research-item">
                    <div class="research-info">
                        <span>âš¡ ç ”ç™¼åŠ é€Ÿ (Lv. <span id="resSpeedLvl">0</span>)</span>
                    </div>
                    <div class="research-desc">æ¸›å°‘è§£é–æ–°ç ²å¡”çš„ç­‰å¾…æ™‚é–“ (æ¯ç´š -10%)</div>
                    <button id="btnResSpeed" class="research-btn">å‡ç´š (250é‡‘)</button>
                </div>

                <!-- ç ”ç©¶é …ç›® 2: ç«åŠ›å¼·åŒ– -->
                <div class="research-item">
                    <div class="research-info">
                        <span>âš”ï¸ ç«åŠ›å¼·åŒ– (Lv. <span id="resDmgLvl">0</span>)</span>
                    </div>
                    <div class="research-desc">æå‡æ‰€æœ‰ç ²å¡”æ”»æ“ŠåŠ› (æ¯ç´š +10%)</div>
                    <button id="btnResDmg" class="research-btn">å‡ç´š (300é‡‘)</button>
                </div>
            </div>
        </div>

        <!-- UI æ§åˆ¶é¢æ¿ -->
        <div id="ui-panel">
            <div id="stats">
                <span id="money">ğŸ’° é‡‘éŒ¢: 450</span>
                <span id="lives">â¤ï¸ ç”Ÿå‘½: 20</span>
                <span id="wave">ğŸŒŠ æ³¢æ•¸: 0</span>
            </div>
            <div id="controls">
                <button id="startWaveBtn" class="start-wave">é–‹å§‹ä¸‹ä¸€æ³¢</button>
                <button id="buyTowerBtn" class="tower-buy" data-type="standard">è³¼è²· ğŸ—¼ (75é‡‘)</button>
                <button id="buyRapidTowerBtn" class="tower-buy" data-type="rapid">è³¼è²· âš¡ (125é‡‘)</button>
                <button id="buySplashTowerBtn" class="tower-buy" data-type="splash">è³¼è²· ğŸ’¥ (175é‡‘)</button>
                <button id="autoBuildBtn">ğŸ¤– è‡ªå‹•å»ºé€ : é—œ</button>
                <button id="researchToggleBtn">ğŸ”¬ ç ”ç©¶å®¤</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // UI å…ƒç´ 
            const moneyEl = document.getElementById('money');
            const livesEl = document.getElementById('lives');
            const waveEl = document.getElementById('wave');
            const startWaveBtn = document.getElementById('startWaveBtn');
            const buyTowerBtns = document.querySelectorAll('.tower-buy');
            const autoBuildBtn = document.getElementById('autoBuildBtn');
            const popupEl = document.getElementById('popup');
            const messageEl = document.getElementById('message');
            
            // ç ”ç©¶å®¤ UI
            const researchToggleBtn = document.getElementById('researchToggleBtn');
            const researchPanel = document.getElementById('researchPanel');
            const closeResearchBtn = document.getElementById('closeResearch');
            const btnResSpeed = document.getElementById('btnResSpeed');
            const btnResDmg = document.getElementById('btnResDmg');
            const resSpeedLvlEl = document.getElementById('resSpeedLvl');
            const resDmgLvlEl = document.getElementById('resDmgLvl');

            const TILE_SIZE = 40;
            const COLS = canvas.width / TILE_SIZE; // 800 / 40 = 20
            const ROWS = canvas.height / TILE_SIZE; // 480 / 40 = 12
            const MAX_BLUEPRINTS = 10; // è—åœ–ä¸Šé™

            let money = 450;
            let lives = 20;
            let wave = 0;
            let gameRunning = true;
            let isAutoBuildOn = false; // è‡ªå‹•å»ºé€ ç‹€æ…‹

            // ç ”ç©¶è³‡æ–™
            const researchLevels = {
                speed: 0,
                damage: 0
            };
            // è¿½è¹¤ç ”ç©¶è¨ˆæ™‚å™¨ { type: remainingFrames }
            const researchTimers = {
                speed: 0,
                damage: 0
            };
            const researchConfig = {
                // time: 600 frames = 10 seconds (at 60fps)
                speed: { baseCost: 250, costInc: 150, max: 5, time: 600 },
                damage: { baseCost: 300, costInc: 200, max: 5, time: 600 }
            };

            const enemies = [];
            const towers = [];
            const projectiles = [];
            const explosions = []; // ç”¨æ–¼ç¯„åœå‚·å®³çš„çˆ†ç‚¸æ•ˆæœ

            // æ•µäººè·¯å¾‘ (x, y åº§æ¨™)
            const waypoints = [
                { x: 0, y: 5 }, { x: 3, y: 5 }, { x: 3, y: 2 }, { x: 7, y: 2 }, { x: 7, y: 8 },
                { x: 12, y: 8 }, { x: 12, y: 3 }, { x: 17, y: 3 }, { x: 17, y: 10 }, { x: 20, y: 10 }
            ].map(p => ({ x: (p.x * TILE_SIZE) + (TILE_SIZE / 2), y: (p.y * TILE_SIZE) + (TILE_SIZE / 2) }));

            // éŠæˆ²ç¶²æ ¼ (0: è‰åœ°, 1: è·¯å¾‘)
            const grid = Array(ROWS).fill(0).map(() => Array(COLS).fill(0));

            // ç¹ªè£½è·¯å¾‘åˆ°ç¶²æ ¼
            function buildPathGrid() {
                ctx.lineWidth = TILE_SIZE * 0.8; // è·¯å¾‘å¯¬åº¦
                ctx.strokeStyle = '#a0522d'; // æ£•è‰²
                ctx.beginPath();
                ctx.moveTo(waypoints[0].x, waypoints[0].y);
                
                // æ¨™è¨˜è·¯å¾‘æ ¼
                function setGridPath(x, y) {
                    const gridX = Math.floor(x / TILE_SIZE);
                    const gridY = Math.floor(y / TILE_SIZE);
                    if (grid[gridY] && grid[gridY][gridX] !== undefined) {
                        grid[gridY][gridX] = 1; // 1 ä»£è¡¨è·¯å¾‘
                    }
                }

                for (let i = 1; i < waypoints.length; i++) {
                    const prev = waypoints[i - 1];
                    const curr = waypoints[i];
                    ctx.lineTo(curr.x, curr.y);

                    // æ¨™è¨˜è·¯å¾‘ä¸Šçš„æ ¼å­
                    const dx = curr.x - prev.x;
                    const dy = curr.y - prev.y;
                    const steps = Math.max(Math.abs(dx), Math.abs(dy)) / (TILE_SIZE / 4);
                    
                    for (let j = 0; j <= steps; j++) {
                        const x = prev.x + (dx * j / steps);
                        const y = prev.y + (dy * j / steps);
                        setGridPath(x, y);
                        setGridPath(x - TILE_SIZE * 0.4, y - TILE_SIZE * 0.4);
                        setGridPath(x + TILE_SIZE * 0.4, y + TILE_SIZE * 0.4);
                        setGridPath(x - TILE_SIZE * 0.4, y + TILE_SIZE * 0.4);
                        setGridPath(x + TILE_SIZE * 0.4, y - TILE_SIZE * 0.4);
                    }
                }
                ctx.stroke();
            }

            // ç¹ªè£½ç¶²æ ¼èƒŒæ™¯ (è·¯å¾‘å’Œè‰åœ°)
            function drawBackground() {
                // ç¹ªè£½è‰åœ° (é è¨­èƒŒæ™¯è‰²)
                ctx.fillStyle = '#5a8c49';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // ç¹ªè£½è·¯å¾‘
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.lineWidth = TILE_SIZE * 0.9;
                ctx.strokeStyle = '#a0522d'; // è·¯å¾‘é¡è‰²
                ctx.beginPath();
                ctx.moveTo(waypoints[0].x - TILE_SIZE, waypoints[0].y); // å¾è¢å¹•å¤–é–‹å§‹
                for (let i = 0; i < waypoints.length; i++) {
                    ctx.lineTo(waypoints[i].x, waypoints[i].y);
                }
                ctx.stroke();

                ctx.lineWidth = TILE_SIZE * 0.7;
                ctx.strokeStyle = '#c27d53'; // è·¯å¾‘å…§å±¤é¡è‰²
                ctx.beginPath();
                ctx.moveTo(waypoints[0].x - TILE_SIZE, waypoints[0].y);
                 for (let i = 0; i < waypoints.length; i++) {
                    ctx.lineTo(waypoints[i].x, waypoints[i].y);
                }
                ctx.stroke();
            }

            // åˆå§‹åŒ–ç¶²æ ¼
            buildPathGrid();

            // æ•µäºº
            class Enemy {
                constructor() {
                    this.x = waypoints[0].x - TILE_SIZE; // å¾å·¦å´è¢å¹•å¤–é–‹å§‹
                    this.y = waypoints[0].y;
                    this.radius = 12;
                    this.waypointIndex = 0;
                    this.speed = 1.5 + (wave * 0.1); // é€Ÿåº¦éš¨æ³¢æ¬¡å¢åŠ 
                    // èª¿é™æ•µäººè¡€é‡
                    this.maxHealth = Math.floor(8 + wave * 2 + Math.pow(wave, 1.05)); // è¡€é‡éš¨æ³¢æ¬¡å¢åŠ 
                    this.health = this.maxHealth;
                    this.value = 5 + wave; // æ“Šæ®ºé‡‘éŒ¢
                }

                update() {
                    if (this.waypointIndex >= waypoints.length) {
                        return; // å·²é”çµ‚é»
                    }

                    const target = waypoints[this.waypointIndex];
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.speed) {
                        this.x = target.x;
                        this.y = target.y;
                        this.waypointIndex++;
                        if (this.waypointIndex >= waypoints.length) {
                            this.reachEnd();
                        }
                    } else {
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                    }
                }

                draw() {
                    // ç¹ªè£½æ•µäºº
                    ctx.font = '24px Arial';
                    ctx.fillText('ğŸ‘¾', this.x - this.radius, this.y + this.radius / 2);

                    // ç¹ªè£½è¡€æ¢
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x - this.radius, this.y - this.radius - 8, this.radius * 2, 5);
                    ctx.fillStyle = 'green';
                    ctx.fillRect(this.x - this.radius, this.y - this.radius - 8, (this.radius * 2) * (this.health / this.maxHealth), 5);
                }

                takeDamage(amount) {
                    this.health -= amount;
                    if (this.health <= 0) {
                        this.die();
                        return true; // æ­»äº¡
                    }
                    return false; // å­˜æ´»
                }

                die() {
                    money += this.value;
                    const index = enemies.indexOf(this);
                    if (index > -1) {
                        enemies.splice(index, 1);
                    }
                }

                reachEnd() {
                    lives--;
                    const index = enemies.indexOf(this);
                    if (index > -1) {
                        enemies.splice(index, 1);
                    }
                    if (lives <= 0) {
                        gameOver();
                    }
                }
            }

            // é˜²ç¦¦å¡”è¨­å®š
            const towerTypes = {
                standard: {
                    emoji: 'ğŸ—¼',
                    range: 120,
                    fireRate: 60, 
                    projectile: { speed: 5, damage: 10, color: 'cyan' },
                    cost: 75,
                    unlockCost: 0,
                    unlockTime: 0 // é è¨­ 0ç§’
                },
                rapid: {
                    emoji: 'âš¡',
                    range: 100,
                    fireRate: 20, 
                    projectile: { speed: 6, damage: 4, color: 'yellow' },
                    cost: 125,
                    unlockCost: 300,
                    unlockTime: 300 // 5ç§’ (60fps * 5)
                },
                splash: {
                    emoji: 'ğŸ’¥',
                    range: 140,
                    fireRate: 100, 
                    projectile: { speed: 3, damage: 15, color: 'orange', splashRadius: 40 },
                    cost: 175,
                    unlockCost: 500,
                    unlockTime: 600 // 10ç§’ (60fps * 10)
                }
            };
            
            // è¿½è¹¤å“ªäº›å¡”å·²è§£é–
            let unlockedTowers = {
                standard: true,
                rapid: false,
                splash: false
            };
            
            // è¿½è¹¤è§£é–é€²åº¦ { type: å‰©é¤˜å¹€æ•¸ }
            let unlockingTimers = {
                standard: 0,
                rapid: 0,
                splash: 0
            };

            class Tower {
                constructor(x, y, type, isBuilt = true) {
                    this.x = (x * TILE_SIZE) + (TILE_SIZE / 2);
                    this.y = (y * TILE_SIZE) + (TILE_SIZE / 2);
                    this.type = type;
                    this.isBuilt = isBuilt; // æ˜¯å¦å·²å»ºé€ å®Œæˆ (è—åœ–æ¨¡å¼)
                    const specs = towerTypes[type];
                    this.emoji = specs.emoji;
                    this.range = specs.range;
                    this.fireRate = specs.fireRate;
                    this.projectileSpec = specs.projectile;
                    this.cost = specs.cost;
                    this.fireCooldown = 0;
                    this.target = null;
                }

                findTarget() {
                    // AI é‚è¼¯ï¼šå„ªå…ˆæ”»æ“Šè·¯å¾‘ä¸Šèµ°æœ€é  (waypointIndex æœ€å¤§) çš„æ•µäºº
                    let bestTarget = null;
                    let maxWaypointIndex = -1;
                    let minDistanceToNext = Infinity;

                    for (const enemy of enemies) {
                        const distance = Math.sqrt(Math.pow(this.x - enemy.x, 2) + Math.pow(this.y - enemy.y, 2));

                        if (distance <= this.range) {
                            if (enemy.waypointIndex > maxWaypointIndex) {
                                maxWaypointIndex = enemy.waypointIndex;
                                bestTarget = enemy;
                                if (enemy.waypointIndex < waypoints.length) {
                                    const nextWp = waypoints[enemy.waypointIndex];
                                    const dx = nextWp.x - enemy.x;
                                    const dy = nextWp.y - enemy.y;
                                    minDistanceToNext = Math.sqrt(dx * dx + dy * dy);
                                } else {
                                    minDistanceToNext = Infinity;
                                }
                            } else if (enemy.waypointIndex === maxWaypointIndex) {
                                if (enemy.waypointIndex < waypoints.length) {
                                    const nextWp = waypoints[enemy.waypointIndex];
                                    const dx = nextWp.x - enemy.x;
                                    const dy = nextWp.y - enemy.y;
                                    const distToNext = Math.sqrt(dx * dx + dy * dy);
                                    if (distToNext < minDistanceToNext) {
                                        minDistanceToNext = distToNext;
                                        bestTarget = enemy;
                                    }
                                }
                            }
                        }
                    }
                    this.target = bestTarget;
                }

                update() {
                    if (!this.isBuilt) return; // è—åœ–ä¸æœƒæ”»æ“Š

                    if (this.fireCooldown > 0) {
                        this.fireCooldown--;
                    }
                    if (this.target) {
                        const distance = Math.sqrt(Math.pow(this.x - this.target.x, 2) + Math.pow(this.y - this.target.y, 2));
                        if (this.target.health <= 0 || distance > this.range) {
                            this.target = null;
                        }
                    }
                    if (!this.target) {
                        this.findTarget();
                    }
                    if (this.target && this.fireCooldown <= 0) {
                        this.shoot();
                        this.fireCooldown = this.fireRate;
                    }
                }

                draw() {
                    ctx.font = '28px Arial';
                    
                    if (!this.isBuilt) {
                        // ç¹ªè£½è—åœ–æ•ˆæœ (åŠé€æ˜ + ç°è‰²)
                        ctx.globalAlpha = 0.4;
                        ctx.fillStyle = '#aaa';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, TILE_SIZE/2 - 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'black';
                    }

                    ctx.fillText(this.emoji, this.x - TILE_SIZE / 2 + 5, this.y + TILE_SIZE / 2 - 8);

                    if (!this.isBuilt) {
                        ctx.globalAlpha = 1.0;
                    }

                    if (placingTowerType && this.x === mouse.x && this.y === mouse.y) {
                         ctx.beginPath();
                         ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                         ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                         ctx.stroke();
                    }
                }

                shoot() {
                    // å¥—ç”¨ç«åŠ›å¼·åŒ–ç ”ç©¶
                    const damageMultiplier = 1 + (researchLevels.damage * 0.1);
                    // è¤‡è£½ spec ä¸¦ä¿®æ”¹å‚·å®³
                    const modifiedSpec = { 
                        ...this.projectileSpec, 
                        damage: this.projectileSpec.damage * damageMultiplier 
                    };
                    projectiles.push(new Projectile(this.x, this.y, this.target, modifiedSpec));
                }
            }

            // å­å½ˆ
            class Projectile {
                constructor(x, y, target, spec) {
                    this.x = x;
                    this.y = y;
                    this.target = target;
                    this.speed = spec.speed;
                    this.damage = spec.damage;
                    this.color = spec.color;
                    this.radius = 4;
                    this.splashRadius = spec.splashRadius || 0;
                }

                update() {
                    if (!this.target || this.target.health <= 0) {
                        this.destroy();
                        return;
                    }

                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.speed || distance < this.radius) {
                        this.hitTarget();
                        return;
                    }

                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }

                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                hitTarget() {
                    if (this.splashRadius > 0) {
                        explosions.push(new Explosion(this.x, this.y, this.splashRadius));
                        for (const enemy of enemies) {
                            const dist = Math.sqrt(Math.pow(this.x - enemy.x, 2) + Math.pow(this.y - enemy.y, 2));
                            if (dist <= this.splashRadius) {
                                enemy.takeDamage(this.damage);
                            }
                        }
                    } else {
                        if (this.target) {
                            this.target.takeDamage(this.damage);
                        }
                    }
                    this.destroy();
                }

                destroy() {
                    const index = projectiles.indexOf(this);
                    if (index > -1) {
                        projectiles.splice(index, 1);
                    }
                }
            }
            
            // çˆ†ç‚¸æ•ˆæœ
            class Explosion {
                constructor(x, y, radius) {
                    this.x = x;
                    this.y = y;
                    this.radius = radius;
                    this.maxRadius = radius;
                    this.duration = 15;
                    this.life = this.duration;
                }
                
                update() {
                    this.life--;
                    if(this.life <= 0) {
                        const index = explosions.indexOf(this);
                        if (index > -1) {
                            explosions.splice(index, 1);
                        }
                    }
                }
                
                draw() {
                    const opacity = this.life / this.duration;
                    this.radius = this.maxRadius * (1 - opacity);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 165, 0, ${opacity * 0.5})`;
                    ctx.fill();
                }
            }

            // éŠæˆ²é‚è¼¯
            let waveInProgress = false;

            function startWave() {
                if (waveInProgress) return;
                waveInProgress = true;
                wave++;
                startWaveBtn.disabled = true;

                const enemyCount = 10 + wave * 3;
                for (let i = 0; i < enemyCount; i++) {
                    setTimeout(() => {
                        if (gameRunning) {
                            enemies.push(new Enemy());
                        }
                    }, i * 500);
                }

                const checkWaveEnd = setInterval(() => {
                    if (enemies.length === 0 && gameRunning) {
                        waveInProgress = false;
                        startWaveBtn.disabled = false;
                        clearInterval(checkWaveEnd);
                    }
                }, 1000);
            }

            function updateUI() {
                moneyEl.textContent = `ğŸ’° é‡‘éŒ¢: ${money}`;
                livesEl.textContent = `â¤ï¸ ç”Ÿå‘½: ${lives}`;
                waveEl.textContent = `ğŸŒŠ æ³¢æ•¸: ${wave}`;
                
                // æ›´æ–°è³¼è²·æŒ‰éˆ•ç‹€æ…‹
                buyTowerBtns.forEach(btn => {
                    const type = btn.dataset.type;
                    const specs = towerTypes[type];
                    const isUnlocked = unlockedTowers[type];
                    const unlockProgress = unlockingTimers[type];
                    
                    btn.className = 'tower-buy'; 
                    btn.innerHTML = '';
                    
                    if (!isUnlocked) {
                        if (unlockProgress > 0) {
                            btn.classList.add('unlocking');
                            const totalTime = calculateUnlockTime(specs.unlockTime); // ä½¿ç”¨è¨ˆç®—å¾Œçš„ç¸½æ™‚é–“
                            const percent = ((totalTime - unlockProgress) / totalTime) * 100;
                            const remainingSeconds = Math.ceil(unlockProgress / 60);
                            
                            const progressBg = document.createElement('div');
                            progressBg.className = 'progress-bar';
                            progressBg.style.width = `${percent}%`;
                            btn.appendChild(progressBg);
                            
                            const textSpan = document.createElement('span');
                            textSpan.textContent = `â³ ç ”ç™¼ä¸­... ${remainingSeconds}s`;
                            textSpan.style.position = 'relative';
                            textSpan.style.zIndex = '2';
                            btn.appendChild(textSpan);
                            
                        } else {
                            btn.classList.add('locked');
                            btn.textContent = `ğŸ”“ è§£é– ${specs.emoji} (${specs.unlockCost}é‡‘)`;
                            if (money < specs.unlockCost) btn.classList.add('expensive');
                        }
                    } else {
                        btn.textContent = `è³¼è²· ${specs.emoji} (${specs.cost}é‡‘)`;
                        if (money < specs.cost) btn.classList.add('expensive');
                        if (placingTowerType === type) btn.classList.add('selected');
                    }
                });

                // æ›´æ–°ç ”ç©¶æŒ‰éˆ•ç‹€æ…‹
                updateResearchUI();
            }
            
            function calculateCost(base, inc, lvl) {
                return base + (inc * lvl);
            }
            
            function calculateUnlockTime(baseTime) {
                 // æ¯ä¸€ç´šæ¸›å°‘ 10% æ™‚é–“
                 const reduction = researchLevels.speed * 0.1;
                 return Math.floor(baseTime * (1 - reduction));
            }

            // æ›´æ–°ç ”ç©¶ UI
            function updateResearchUI() {
                resSpeedLvlEl.textContent = researchLevels.speed;
                resDmgLvlEl.textContent = researchLevels.damage;

                // ç ”ç™¼åŠ é€ŸæŒ‰éˆ•
                updateResearchButton(
                    btnResSpeed, 
                    'speed', 
                    researchConfig.speed, 
                    researchLevels.speed, 
                    researchTimers.speed
                );

                // ç«åŠ›å¼·åŒ–æŒ‰éˆ•
                updateResearchButton(
                    btnResDmg, 
                    'damage', 
                    researchConfig.damage, 
                    researchLevels.damage, 
                    researchTimers.damage
                );
            }

            // è¼”åŠ©å‡½æ•¸ï¼šæ›´æ–°å–®å€‹ç ”ç©¶æŒ‰éˆ•
            function updateResearchButton(btn, type, config, currentLevel, timer) {
                // æ¸…ç©ºå…§å®¹
                btn.innerHTML = '';
                btn.className = 'research-btn';

                if (currentLevel >= config.max) {
                    btn.textContent = "å·²é”ä¸Šé™ (MAX)";
                    btn.disabled = true;
                    btn.classList.add('maxed');
                    return;
                }

                if (timer > 0) {
                    // ç ”ç©¶ä¸­
                    btn.classList.add('unlocking');
                    btn.disabled = true; // ç ”ç©¶ä¸­ä¸å¯é»æ“Š

                    const totalTime = config.time;
                    const percent = ((totalTime - timer) / totalTime) * 100;
                    const remainingSeconds = Math.ceil(timer / 60);

                    const progressBg = document.createElement('div');
                    progressBg.className = 'progress-bar';
                    progressBg.style.width = `${percent}%`;
                    btn.appendChild(progressBg);

                    const textSpan = document.createElement('span');
                    textSpan.textContent = `ğŸ§ª ç ”ç©¶ä¸­... ${remainingSeconds}s`;
                    textSpan.style.position = 'relative';
                    textSpan.style.zIndex = '2';
                    btn.appendChild(textSpan);
                } else {
                    // æ­£å¸¸ç‹€æ…‹
                    const nextCost = calculateCost(config.baseCost, config.costInc, currentLevel);
                    btn.textContent = `å‡ç´š (${nextCost}é‡‘)`;
                    btn.disabled = money < nextCost;
                    if (money < nextCost) {
                        // é›–ç„¶ CSS æœ‰ disabled æ¨£å¼ï¼Œä½†ä¹Ÿå¯ä»¥åŠ  expensive class æç¤º
                    }
                }
            }

            function showMessage(text, isSuccess = false) {
                messageEl.textContent = text;
                messageEl.className = isSuccess ? 'success' : '';
                messageEl.style.opacity = 1;
                setTimeout(() => {
                    messageEl.style.opacity = 0;
                }, 2000);
            }

            function gameOver() {
                if (!gameRunning) return;
                gameRunning = false;
                popupEl.textContent = "éŠæˆ²çµæŸï¼";
                popupEl.style.display = 'block';
            }

            // è‡ªå‹•å»ºé€ é‚è¼¯ (æª¢æŸ¥å·²æ”¾ç½®çš„è—åœ–)
            function checkBlueprints() {
                const blueprints = towers.filter(t => !t.isBuilt);
                for (const bp of blueprints) {
                    if (money >= bp.cost) {
                        money -= bp.cost;
                        bp.isBuilt = true;
                        explosions.push(new Explosion(bp.x, bp.y, 20));
                        updateUI();
                        break; 
                    }
                }
            }
            
            // æ›´æ–°è§£é–å’Œç ”ç©¶é€²åº¦
            function updateUnlocking() {
                let needsUpdate = false;
                
                // 1. ç ²å¡”è§£é–
                for (const type in unlockingTimers) {
                    if (unlockingTimers[type] > 0) {
                        unlockingTimers[type]--;
                        needsUpdate = true;
                        if (unlockingTimers[type] <= 0) {
                            unlockingTimers[type] = 0;
                            unlockedTowers[type] = true;
                            showMessage(`${towerTypes[type].emoji} ç ”ç™¼å®Œæˆï¼`, true);
                            explosions.push(new Explosion(canvas.width/2, canvas.height/2, 200)); 
                            needsUpdate = true;
                        }
                    }
                }

                // 2. ç ”ç©¶å‡ç´š
                for (const type in researchTimers) {
                    if (researchTimers[type] > 0) {
                        researchTimers[type]--;
                        needsUpdate = true;
                        if (researchTimers[type] <= 0) {
                            researchTimers[type] = 0;
                            researchLevels[type]++; // å‡ç´š
                            const name = type === 'speed' ? 'ç ”ç™¼åŠ é€Ÿ' : 'ç«åŠ›å¼·åŒ–';
                            showMessage(`${name} å‡ç´šè‡³ Lv.${researchLevels[type]}`, true);
                            needsUpdate = true;
                        }
                    }
                }

                if (needsUpdate && frameCount % 5 === 0) { // ç¨å¾®é »ç¹ä¸€é»æ›´æ–° UI ä»¥é¡¯ç¤ºå¹³æ»‘é€²åº¦
                     updateUI();
                }
            }
            
            // ç ”ç©¶é¢æ¿é–‹é—œ
            researchToggleBtn.addEventListener('click', () => {
                researchPanel.style.display = researchPanel.style.display === 'block' ? 'none' : 'block';
            });
            closeResearchBtn.addEventListener('click', () => {
                researchPanel.style.display = 'none';
            });

            // ç ”ç©¶å‡ç´šé‚è¼¯
            btnResSpeed.addEventListener('click', () => {
                startResearch('speed');
            });

            btnResDmg.addEventListener('click', () => {
                startResearch('damage');
            });

            function startResearch(type) {
                // å¦‚æœå·²ç¶“åœ¨ç ”ç©¶ä¸­ï¼Œä¸å‹•ä½œ
                if (researchTimers[type] > 0) return;

                const config = researchConfig[type];
                const currentLevel = researchLevels[type];
                const cost = calculateCost(config.baseCost, config.costInc, currentLevel);

                if (money >= cost && currentLevel < config.max) {
                    money -= cost;
                    // é–‹å§‹è¨ˆæ™‚
                    researchTimers[type] = config.time;
                    updateUI(); // ç«‹å³æ›´æ–°é¡¯ç¤ºé€²åº¦æ¢
                } else if (money < cost) {
                    showMessage('é‡‘éŒ¢ä¸è¶³ï¼');
                }
            }

            // åˆ‡æ›è‡ªå‹•å»ºé€ 
            autoBuildBtn.addEventListener('click', () => {
                isAutoBuildOn = !isAutoBuildOn;
                autoBuildBtn.textContent = isAutoBuildOn ? "ğŸ¤– è‡ªå‹•å»ºé€ : é–‹" : "ğŸ¤– è‡ªå‹•å»ºé€ : é—œ";
                if (isAutoBuildOn) {
                    autoBuildBtn.classList.add('active');
                } else {
                    autoBuildBtn.classList.remove('active');
                }
            });


            // æ»‘é¼ /æ”¾ç½®é‚è¼¯
            let placingTowerType = null;
            let mouse = { x: 0, y: 0, gridX: 0, gridY: 0 };

            function getMousePos(evt) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (evt.clientX - rect.left) * scaleX;
                const y = (evt.clientY - rect.top) * scaleY;
                return { x, y };
            }

            canvas.addEventListener('mousemove', (e) => {
                const pos = getMousePos(e);
                mouse.x = pos.x;
                mouse.y = pos.y;
                mouse.gridX = Math.floor(mouse.x / TILE_SIZE);
                mouse.gridY = Math.floor(mouse.y / TILE_SIZE);
            });

            canvas.addEventListener('click', () => {
                if (!placingTowerType) return;

                const specs = towerTypes[placingTowerType];
                const cost = specs.cost;
                
                if (canPlaceTower(mouse.gridX, mouse.gridY)) {
                    const currentBlueprints = towers.filter(t => !t.isBuilt).length;
                    let builtNow = false;
                    
                    if (money >= cost && !isAutoBuildOn) {
                        money -= cost;
                        builtNow = true;
                    } else {
                        builtNow = false; 
                    }

                    if (!builtNow && currentBlueprints >= MAX_BLUEPRINTS) {
                        showMessage(`è—åœ–æ•¸é‡å·²é”ä¸Šé™ (${MAX_BLUEPRINTS}å€‹)ï¼`);
                        return;
                    }

                    towers.push(new Tower(mouse.gridX, mouse.gridY, placingTowerType, builtNow));
                    grid[mouse.gridY][mouse.gridX] = 2; 
                    
                    updateUI();
                }
            });
            
            function canPlaceTower(gridX, gridY) {
                if (!grid[gridY] || grid[gridY][gridX] === undefined) return false;
                return grid[gridY][gridX] === 0;
            }

            function drawPlacementPreview() {
                if (!placingTowerType) return;
                const gridX = mouse.gridX;
                const gridY = mouse.gridY;
                if (gridX < 0 || gridX >= COLS || gridY < 0 || gridY >= ROWS) return;

                const x = (gridX * TILE_SIZE) + (TILE_SIZE / 2);
                const y = (gridY * TILE_SIZE) + (TILE_SIZE / 2);
                const specs = towerTypes[placingTowerType];

                ctx.globalAlpha = 0.5;
                ctx.font = '28px Arial';
                ctx.fillText(specs.emoji, x - TILE_SIZE / 2 + 5, y + TILE_SIZE / 2 - 8);
                
                ctx.beginPath();
                ctx.arc(x, y, specs.range, 0, Math.PI * 2);
                
                if (canPlaceTower(gridX, gridY)) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                } else {
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                }
                ctx.stroke();
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            // æŒ‰éˆ•äº‹ä»¶
            startWaveBtn.addEventListener('click', startWave);

            buyTowerBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const type = btn.dataset.type;
                    const specs = towerTypes[type];
                    
                    if (!unlockedTowers[type]) {
                        if (unlockingTimers[type] > 0) return;

                        if (money >= specs.unlockCost) {
                            money -= specs.unlockCost;
                            // å¥—ç”¨ç ”ç©¶åŠ é€Ÿ
                            unlockingTimers[type] = calculateUnlockTime(specs.unlockTime);
                            updateUI();
                        } else {
                            showMessage('é‡‘éŒ¢ä¸è¶³ä»¥è§£é–ï¼');
                        }
                    } else {
                        if (placingTowerType === type) {
                            placingTowerType = null;
                        } else {
                            placingTowerType = type;
                        }
                        updateUI();
                    }
                });
            });
            
            // éŠæˆ²ä¸»å¾ªç’°
            let frameCount = 0; 
            
            function gameLoop() {
                if (!gameRunning) return;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBackground();

                frameCount++;
                if (isAutoBuildOn && frameCount % 10 === 0) {
                    checkBlueprints();
                }
                
                updateUnlocking();

                // ä¿®æ­£ï¼šæª¢æŸ¥æ˜¯å¦ç‚º undefined
                for (let i = enemies.length - 1; i >= 0; i--) {
                    if (enemies[i]) {
                        enemies[i].update();
                    }
                    if (enemies[i]) { // å†æª¢æŸ¥ä¸€æ¬¡ï¼Œå› ç‚º update å¯èƒ½ç§»é™¤äº†å®ƒ
                        enemies[i].draw();
                    }
                }

                towers.forEach(tower => {
                    tower.update();
                    tower.draw();
                });

                // ä¿®æ­£ï¼šæª¢æŸ¥æ˜¯å¦ç‚º undefined
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    if (projectiles[i]) {
                        projectiles[i].update();
                    }
                    if (projectiles[i]) {
                        projectiles[i].draw();
                    }
                }
                
                // ä¿®æ­£ï¼šæª¢æŸ¥æ˜¯å¦ç‚º undefined
                for (let i = explosions.length - 1; i >= 0; i--) {
                     if (explosions[i]) {
                        explosions[i].update();
                    }
                    if (explosions[i]) {
                        explosions[i].draw();
                    }
                }

                drawPlacementPreview();
                requestAnimationFrame(gameLoop);
            }

            updateUI();
            drawBackground();
            gameLoop();
        });
    </script>
</body>
</html>